package com.zzia.wngn.design.iterator;

/**
 * @author wanggang
 * @title
 * @date 2016/5/26 21:27
 * @email wanggang@vfou.com
 * @descripe <p>
 * 提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。<br>
 * <p/>
 * 适用性：<br>
 * 访问一个聚合对象的内容而无需暴露它的内部表示。<br>
 * 支持对聚合对象的多种遍历。<br>
 * 为遍历不同的聚合结构提供一个统一的接口(即, 支持多态迭代)。<br>
 * <p/>
 * terator: 抽象迭代器：所有迭代器都需要实现的接口，提供了游走聚合对象元素之间的方法。<br>
 * ConcreteIterator: 具体迭代器。利用这个具体的迭代器能够对具体的聚合对象进行遍历。每一个聚合对象都应该对应一个具体的迭代器。<br>
 * Aggregate: 抽象聚合类。<br>
 * ConcreteAggregate: 具体聚合类。实现creatorIterator()方法，返回该聚合对象的迭代器。<br>
 * <p/>
 * 优点<br>
 * 1、它支持以不同的方式遍历一个聚合对象。<br>
 * 2、迭代器简化了聚合类。<br>
 * 3、在同一个聚合上可以有多个遍历。<br>
 * 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。<br>
 * <p/>
 * 缺点<br>
 * 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。<br>
 * <p/>
 * 模式使用场景<br>
 * 1、访问一个聚合对象的内容而无须暴露它的内部表示。<br>
 * 2、需要为聚合对象提供多种遍历方式。<br>
 * 3、为遍历不同的聚合结构提供一个统一的接口。<br>
 * <p/>
 * 模式总结<br>
 * 1、迭代器模式提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示。<br>
 * 2、将遍历聚合对象中数据的行为提取出来，封装到一个迭代器中，通过专门的迭代器来遍历聚合对象的内部数据，这就是迭代器模式的本质。
 * 迭代器模式是“单一职责原则”的完美体现。<br>
 * 3、当使用迭代器的时候，我们依赖聚合提供遍历。<br>
 * 4、迭代器提供了一个通用的接口，让我们遍历聚合的项，放我们编码使用聚合项时，就可以使用多态机制。<br>
 */
public interface Iterator {

    public boolean hasNext();

    public Object next();
}
