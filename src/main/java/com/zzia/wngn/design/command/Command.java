package com.zzia.wngn.design.command;

/**
 * @author wanggang
 * @title
 * @date 2016/5/30 9:25
 * @email wanggang@vfou.com
 * @descripe 抽象命令类 Command命令接口，为所有的命令声明一个接口。所有的命令都应该实现它
 * <p>
 * 意图<br>
 * 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。
 * <p>
 * 适用性：<br>
 * 抽象出待执行的动作以参数化某对象，你可用过程语言中的回调（call back）函数表达这种参数化机制。
 * 所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。Command 模式是回调机制的一个面向对象的替代品。
 * <br>
 * 在不同的时刻指定、排列和执行请求。一个Command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种
 * 与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。
 * <br>
 * 支持取消操作。Command的Excute 操作可在实施操作前将状态存储起来，在取消操作时这个状态用来消除该操作的影响。
 * Command 接口必须添加一个Unexecute操作，该操作取消上一次Execute调用的效果。执行的命令被存储在一个历史列表中。
 * 可通过向后和向前遍历这一列表并分别调用Unexecute和Execute来实现重数不限的“取消”和“重做”。
 * <br>
 * 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。在Command接口中添加装载操作和存储操作，
 * 可以用来保持变动的一个一致的修改日志。从崩溃中恢复的过程包括从磁盘中重新读入记录下来的命令并用Execute操作重新
 * 执行它们。
 * <br>
 * 用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务( transaction)的信息系统中很常见。
 * 一个事务封装了对数据的一组变动。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，
 * 使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。
 * <p>
 * 优点<br>
 * 1. 降低了系统耦合度<br>
 * 2. 新的命令可以很容易添加到系统中去。<br>
 * <p>
 * 缺点<br>
 * <p>
 * 使用命令模式可能会导致某些系统有过多的具体命令类。
 * <p>
 * 模式使用场景<br>
 * 1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。<br>
 * 2.系统需要在不同的时间指定请求、将请求排队和执行请求。<br>
 * 3.系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。<br>
 * 4.系统需要将一组操作组合在一起，即支持宏命令。<br>
 * <p>
 * 总结<br>
 * 1. 命令模式的本质就是将命令对象进行封装打包，将发出命令的责任和执行命令的责任进行割开。<br>
 * 2. 命令模式中发送者只需要知道如何发送请求命令，无须关心命令执行具体过程。<br>
 * 3. 在发送者和接收者两者间是通过命令对象进行沟通的。请求命令本身就当做一个对象在两者间进行传递，
 * 它封装了接收者和一组动作。<br>
 * 4. 命令模式支持撤销。<br>
 * 5. 命令模式队列请求和日志请求。<br>
 */
public interface Command {

    public void execute();

}
